import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Random;
/*
      Initial Comment
   a. The purpose of this program is to extend what was done in the first homework by assigning each process a unique process id
      creating a ready queue, and out put of the priority queue, then printing out the process id's
   b. Ryan Meyer and Nathaniel Sullivano
   c. The program requires no outside input as the program automatically generates the inputs necessary for the program
   d. In order to use the program just compile and run it with no additional input
   e. The program expects a process object that implement the comparable interface in order to print the necessary information
   f. There are currently no issues that could happen except for the still ever so slim chance of a meteorite striking your current location

*/
public class ProcessScheduler {
     /*

        No Necessary Pre-Inputs
        ---
        Expected Post Conditions / Output
        ---
        Step 14:
        The new generated process is P24:1
        The processes in the priority queue are: P19:1 P21:1 P17:3 P24:1 P15:7 P18:5 P20:3 P13:7 P22:4 P11:9 P16:8 P9:10 P2:7 P3:7 P12:4 P5:9 P14:8 P1:9 P23:4
        The processes in the ready queue are: P8:1 P6:3 P10:5 P7:5 P4:7
        ---

     */
    public static void main(String[] args) {
        // Initialize the priority queue for long-term processes
        PriorityQueue<Process> longTermQueue = new PriorityQueue<>();

        // Generate 10 initial processes with random priorities and execution times
        Random rand = new Random();
        for (int i = 1; i <= 10; i++) {
            int priority = rand.nextInt(10) + 1; // Random priority [1-10]
            int executionTime = rand.nextInt(20) + 1; // Random execution time [1-20]
            Process process = new Process("P" + i, priority, executionTime);
            longTermQueue.add(process);
        }

        // Initialize the ready queue for short-term processes in the lovely in-efficient round-robin style
        Queue<Process> readyQueue = new PriorityQueue<>(5, (p1, p2) -> Integer.compare(p1.getPriority(), p2.getPriority()));

        // Generate and process additional 15 processes
        int totalProcessesGenerated = 10;
        while (totalProcessesGenerated < 25) {
            // Generate a new process
            int priority = rand.nextInt(10) + 1;
            int executionTime = rand.nextInt(20) + 1;
            Process newProcess = new Process("P" + (totalProcessesGenerated + 1), priority, executionTime);

            // Add the new process to the long-term queue
            longTermQueue.add(newProcess);
            totalProcessesGenerated++;

            // Move processes from long-term queue to ready queue (if needed)
            while (!longTermQueue.isEmpty() && readyQueue.size() < 5) {
                Process nextProcess = longTermQueue.poll();
                readyQueue.add(nextProcess);
            }

            // Print process information
            System.out.println("Step " + (totalProcessesGenerated - 10) + ":");
            System.out.println("The new generated process is " + newProcess);
            System.out.print("The processes in the priority queue are: ");
            for (Process p : longTermQueue) {
                System.out.print(p + " ");
            }
            System.out.print("\nThe processes in the ready queue are: ");
            for (Process p : readyQueue) {
                System.out.print(p + " ");
            }
            System.out.println("\n");
        }
    }
}

class Process implements Comparable<Process> {
    private String processId;
    private int priority;
    private int executionTime;

    public Process(String processId, int priority, int executionTime) {
        this.processId = processId;
        this.priority = priority;
        this.executionTime = executionTime;
    }

    public String getProcessId() {
        return processId;
    }

    public int getPriority() {
        return priority;
    }

    public int getExecutionTime() {
        return executionTime;
    }

    @Override
    public int compareTo(Process other) {
        return Integer.compare(this.priority, other.priority);
    }

    @Override
    public String toString() {
        return processId + ":" + priority;
    }
}
